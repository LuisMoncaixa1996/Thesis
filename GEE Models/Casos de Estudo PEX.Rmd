---
title: "Untitled"
output:
  html_document: default
  pdf_document: default
date: '2022-04-01'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

```{r}

library(dplyr)
library(caTools)
library(pROC)
library(geepack)
library(spind)
library(gee)
library(ROCR)
library(MESS)
library(readxl)
library(ggplot2)

```




``` {r}
#Carregamento do dataset e criação dos datasets de teste e treino.
#Os datasets foram divididos de três formas diferentes. (80% - Treino / 20% - Teste) (75% - Treino/ 25% - Teste) (70% - Treino/ 30% - Teste)

base_de_dados_PEX_corrigida19fev2018 <- read_excel("C:/Users/luism/Desktop/Mestrado Bioinformática/Tese/Packages Study/Oftal DataBase/base de dados - PEX_corrigida19fev2018.xlsx")
data = base_de_dados_PEX_corrigida19fev2018
names(data)[names(data) == "Dil pp (mm)"] <- "Dilpp"
names(data)[names(data) == "LIO (Dp)"] <- "LIO_Dp"
names(data)[names(data) == "Local da LIO"] <- "Local_da_LIO"




data_for_gee = data
data$Lat = as.factor(data$Lat)
data$Dilpp = as.factor(data$Dilpp)
data$Local_da_LIO = as.factor(data$Local_da_LIO)
data$Processo = as.factor(data$Processo)

olho = table(unique_process$Lat)

```



``` {r}
#Análise Exploratória

unique_process = data[!duplicated(data$Processo), ]

Idade = table(unique_process$Idade)
Sexo = table(unique_process$Sexo)

barplot(Idade, main='Idades dos pacientes',ylim = c(0,20), xlab = 'Idade', ylab = 'Nº de pacientes',col = 'black', border = 'white')



Genero <- c("Masculino", "Feminino")
pct <- round(Sexo/sum(Sexo)*100)

kkakaka = data.frame(Sexo)
pct = paste(pct,"%")
ggplot(kkakaka, aes(x="", y=pct, fill=Genero)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  geom_text(aes(label = pct), position = position_stack(vjust = 0.5), color = "white", size=6) +
  scale_fill_brewer(palette="Set1") +
  ggtitle("Sexo dos pacientes observados")





cl1 = which(data$Dilpp==1)
cl2 = which(data$Dilpp==2)
cl3 = which(data$Dilpp==3)
cl4 = which(data$Dilpp==4)
cl5 = which(data$Dilpp==5)

total_table = rbind(table(data$Lat[cl1]),table(data$Lat[cl2]),table(data$Lat[cl3]),table(data$Lat[cl4]),table(data$Lat[cl5]))

x = barplot(total_table,beside = T, col = c('black','red','blue','green','yellow'),ylab = 'Frequência', names = c('Olho Direito', 'Olho Esquerdo'), legend.text=c('≥8 mm','≥7-8 mm','≥6-7 mm','≥5-6 mm','<5 mm'),args.legend = list(bty = "n", x = "top", ncol = 3),ylim=c(0,300),  main = 'Dilatação pupilar nos diferentes olhos')

text(x=x, y= total_table +10, labels=as.character(total_table))


total_table_PEX = rbind(table(data$PEX[cl1]),table(data$PEX[cl2]),table(data$PEX[cl3]),table(data$PEX[cl4]),table(data$PEX[cl5]))

pex_plot = barplot(total_table_PEX,beside = T,col = c('black','red','blue','green','yellow'),ylab = 'Frequência', names = c('S/Presença de PEX', 'Presença de PEX'),legend.text = c('≥8 mm','≥7-8 mm','≥6-7 mm','≥5-6 mm','<5 mm'),args.legend = list(bty = "n", x = "top", ncol = 3),ylim=c(0,500),  main = 'Dilatação pupilar considerando a presença de PEX')
text(x=pex_plot, y= total_table_PEX + 15,labels=as.character(total_table_PEX) )




Saco = which(data$Local_da_LIO==1)
Sulco = which(data$Local_da_LIO==2)
CA = which(data$Local_da_LIO==3)
S_LIO = which(data$Local_da_LIO==4)
Local_table = rbind(table(data$Lat[Saco]),table(data$Lat[Sulco]),table(data$Lat[CA]),table(data$Lat[S_LIO]))

local_plot = barplot(Local_table,beside = T,col = c('black','red','blue','green'),ylab = 'Frequência', names = c('Olho Direito', 'Olho Esquerdo'),legend.text = c('Saco','Sulco','CA','s/LIO'),args.legend = list(bty = "n", x = "top", ncol = 3),ylim=c(0,350),  main = 'Local da lente intraocular em cada um dos olhos')
text(x=local_plot, y= Local_table + 15,labels=as.character(Local_table) )



NAcount = sapply(data, function(x) sum(is.na(x)))
par(mar=c(10,8,1,1))
barplot(NAcount,ylab = 'Valores Omissos (NAs)', ylim = c(0,500),col = 'gray',las=2)


PEX = which(data$PEX==1)
s_PEX = which(data$PEX==0)

Olho <- c("Direito", "Esquerdo")
PEX_in_EYE = table(data$Lat[PEX])
pct_presenca <- round(PEX_in_EYE/sum(PEX_in_EYE)*100)

dta_pex = data.frame(PEX_in_EYE)
pct_presenca = paste(pct_presenca,"%")
ggplot(dta_pex, aes(x="", y=pct_presenca, fill=Olho)) +
  geom_bar(stat="identity", width=1, color="white") +
  coord_polar("y", start=0) +
  theme_void() + 
  geom_text(aes(label = pct_presenca), position = position_stack(vjust = 0.5), color = "black", size=6) +
  scale_fill_brewer(palette="Blues") +
  ggtitle("Presença da pseudoexfoliação nos diferentes olhos")

```





```{r}

smp_size <- floor(0.80 * nrow(data))
smp_size2 <- floor(0.70 * nrow(data))
smp_size3 <- floor(0.75 * nrow(data))
set.seed(123)
train_ind <- sample(seq_len(nrow(data)), size = smp_size)
train_ind2 <- sample(seq_len(nrow(data)),size = smp_size2)
train_ind3 <- sample(seq_len(nrow(data)),size = smp_size3)
train_80 <- data[train_ind, ]
train_75 <- data[train_ind3,]
train_70 <- data[train_ind2,]
test_80 <- data[-train_ind, ]
test_75 <- data[-train_ind3, ]
test_70 <- data[-train_ind2, ]

#Tabela para comparação das diferentes métricas
tab = matrix(nrow = 3,ncol = 2)
colnames(tab) = c("ACC","AUC")
rownames(tab) = c("Modelo_70/30","Modelo_75/25","Modelo_80/20")

tab2 = matrix(nrow = 3,ncol = 2)
colnames(tab2) = c("ACC","AUC")
rownames(tab2) = c("Modelo_All","Modelo_CP","Modelo_LO")

```





Foram definidos 3 modelos GEE considerando diferentes covariáveis: 
-> Modelo considerando todas as covariáveis de interesse (Modelo_All)
-> Modelo considerando apenas as covariáveis correspondentes ao individuo (Modelo_CP)
-> Modelo considerando as covariáveis correspondentes à LIO e respetiva posição. (Modelo_LO)

Uma vez que o package (gee) permite apenas analisar o modelo gee e não permite a sua utilização para validação cruzada nem obter o valor de QIC para identificar a melhor estrutura de correlação, foi apenas utilizado o package (geepack) para os diferentes datasets de treino, de forma a obter métricas (acc e auc) que permitam identificar qual o modelo mais adequado para análise GEE. De forma a complementar a análise foram geradas, também as respetivas curvas ROC.


```{r}
#MODELO CONSIDERANDO TODAS AS COVARIÁVEIS

#Foram utilizados dois packages de modo a realizar os modelos GEE (GEE & Geepack). Os packages permitem verficar qual a melhor estrutura de correlação através do valor de QIC. 

#MODELOS 70_30
#GEEPACK models com diferentes estruturas de correlação e respetivos valores QIC
GEEPACK_Modelo_70_30_ex = geeglm(PEX~(I(Idade) + Sexo + Lat + Dilpp + Local_da_LIO ) , id = train_70[["Processo"]] , data = train_70, family = binomial, corstr = "exchangeable",scale.fix = TRUE)
summary(GEEPACK_Modelo_70_30_ex)
MESS::QIC(GEEPACK_Modelo_70_30_ex)

GEEPACK_Modelo_70_30_ar1 = geeglm(PEX~(I(Idade) + Sexo + Lat + Dilpp + Local_da_LIO ) , id = Processo , data = train_70, family = binomial, corstr = "ar1",scale.fix = TRUE)
summary(GEEPACK_Modelo_70_30_ar1)
MESS::QIC(GEEPACK_Modelo_70_30_ar1)

GEEPACK_Modelo_70_30_ind = geeglm(PEX~(I(Idade) + Sexo + Lat + Dilpp + Local_da_LIO ) , id = Processo , data = train_70, family = binomial, corstr = "independence",scale.fix = TRUE)
summary(GEEPACK_Modelo_70_30_ind)
MESS::QIC(GEEPACK_Modelo_70_30_ind)

#Como o valor de QIC é semelhante em todos os modelos para a análise ROC e do modelo GEE foi considerada a estrutura de correlação como "exchangeable"


#Modelo 75_25

GEEPACK_Modelo_75_25_ex = geeglm(PEX~(I(Idade) + Sexo + Lat + Dilpp + Local_da_LIO) , id = Processo , data = train_75, family = binomial, corstr = "exchangeable")
summary(GEEPACK_Modelo_75_25_ex)
MESS::QIC(GEEPACK_Modelo_75_25_ex)

GEEPACK_Modelo_75_25_ar1 = geeglm(PEX~(I(Idade) + Sexo + Lat + Dilpp + Local_da_LIO) , id = Processo , data = train_75, family = binomial, corstr = "ar1")
summary(GEEPACK_Modelo_75_25_ar1)
MESS::QIC(GEEPACK_Modelo_75_25_ar1)

GEEPACK_Modelo_75_25_ind = geeglm(PEX~(I(Idade) + Sexo + Lat + Dilpp  + Local_da_LIO) , id = Processo , data = train_75, family = binomial, corstr = "independence")
summary(GEEPACK_Modelo_75_25_ind)
MESS::QIC(GEEPACK_Modelo_75_25_ind)


#Modelo 80_20

GEEPACK_Modelo_80_20_ex = geeglm(PEX~(I(Idade) + Sexo + Lat + Dilpp + Local_da_LIO) , id = Processo , data = train_80, family = binomial, corstr = "exchangeable")
summary(GEEPACK_Modelo_80_20_ex)
MESS::QIC(GEEPACK_Modelo_80_20_ex)

GEEPACK_Modelo_80_20_ar1 = geeglm(PEX~(I(Idade) + Sexo + Lat + Dilpp + Local_da_LIO) , id = Processo , data = train_80, family = binomial, corstr = "ar1")
summary(GEEPACK_Modelo_80_20_ar1)
MESS::QIC(GEEPACK_Modelo_80_20_ar1)

GEEPACK_Modelo_80_20_ind = geeglm(PEX~(Idade + Sexo + Lat + Dilpp + Local_da_LIO) , id = Processo , data = train_80, family = binomial, corstr = "independence")
summary(GEEPACK_Modelo_80_20_ind)
MESS::QIC(GEEPACK_Modelo_80_20_ind)



#Métricas para validação dos modelos e respetivas curvas ROC


#Modelo 70_30
library(ROCR)
pred_70_30 = predict(GEEPACK_Modelo_70_30_ex,test_70,type="response")
pred_70_30 = prediction(pred_70_30, test_70$PEX)
perf_70_30 = performance(pred_70_30, "acc")

#ACC
max_ind_70_30 = which.max(slot(perf_70_30, "y.values")[[1]] )
acc_70_30 = slot(perf_70_30, "y.values")[[1]][max_ind_70_30]
tab[1][1] = acc_70_30

#Curva ROC
roc_70_30 = performance(pred_70_30,"tpr","fpr")
plot(roc_70_30, colorize = T, lwd = 2)
auc_70_30 = performance(pred_70_30, measure = "auc")
tab[1,2]  = auc_70_30@y.values[[1]]


#Modelo 75_25
pred_75_25 = predict(GEEPACK_Modelo_75_25_ex,test_75,type="response")
pred_75_25 = prediction(pred_75_25, test_75$PEX)
perf_75_25 = performance(pred_75_25, "acc")

#ACC
max_ind_75_25 = which.max(slot(perf_75_25, "y.values")[[1]] )
acc_75_25 = slot(perf_75_25, "y.values")[[1]][max_ind_75_25]
tab[2,1] = acc_75_25

#Curva ROC
roc_75_25 = performance(pred_75_25,"tpr","fpr")
plot(roc_75_25, colorize = T, lwd = 2)
auc_75_25 = performance(pred_75_25, measure = "auc")
tab[2,2]  = auc_75_25@y.values[[1]]


#Modelo 80_20
pred_80_20 = predict(GEEPACK_Modelo_80_20_ex,test_80,type="response")
pred_80_20 = prediction(pred_80_20, test_80$PEX)
perf_80_20 = performance(pred_80_20, "acc")

#ACC
max_ind_80_20 = which.max(slot(perf_80_20, "y.values")[[1]] )
acc_80_20 = slot(perf_80_20, "y.values")[[1]][max_ind_80_20]
tab[3,1] = acc_80_20

#Curva ROC
roc_80_20 = performance(pred_80_20,"tpr","fpr")
plot(roc_80_20, colorize = T, lwd = 2)
auc_80_20 = performance(pred_80_20, measure = "auc")
tab[3,2]  = auc_80_20@y.values[[1]]



tab2[1,1]= acc_70_30
tab2[1,2]= auc_70_30@y.values[[1]]

tab


```

Considerando a tabela com os diferentes splits do dataset, verificou-se que o modelo com 80% treino e 20% teste, apresenta as melhores métricas quando aplicada a análise ROC, pelo que será apenas considerada esta divisão nos restantes modelos.

``` {r}
#Modelo considerando as caracteristicas pessoais

library(geepack)
Modelo_70_30_CP = geeglm(PEX~Idade + Sexo + Lat  , id = Processo , data = train_70, family = binomial, corstr = "exchangeable")
summary(Modelo_70_30_CP)
MESS::QIC(Modelo_70_30_CP)


pred_70_30_CP = predict(Modelo_70_30_CP,test_70,type="response")
pred_70_30_CP = prediction(pred_70_30_CP, test_70$PEX)
perf_70_30_CP = performance(pred_70_30_CP, "acc")

#ACC
max_ind_70_30_CP = which.max(slot(perf_70_30_CP, "y.values")[[1]] )
acc_70_30_CP = slot(perf_70_30_CP, "y.values")[[1]][max_ind_70_30_CP]
tab2[2,1] = acc_70_30_CP

#Curva ROC
roc_70_30_CP = performance(pred_70_30_CP,"tpr","fpr")
plot(roc_70_30_CP, colorize = T, lwd = 2)
auc_70_30_CP = performance(pred_70_30_CP, measure = "auc")
tab2[2,2]  = auc_70_30_CP@y.values[[1]]
tab2


#Estruturas de correlação

Modelo_70_30_CP_full = geeglm(PEX~Idade + Sexo + Lat  , id = Processo , data = data, family = binomial, corstr = "exchangeable")
summary(Modelo_70_30_CP_full)
MESS::QIC(Modelo_70_30_CP_full)




```


``` {r}
#Modelo considerando a posicão da Lente Intra-Ocular.


library(geepack)
Modelo_70_30_LO = geeglm(PEX~Lat + Dilpp + Local_da_LIO , id = Processo , data = train_70, family = binomial, corstr = "exchangeable")
summary(Modelo_70_30_LO)
MESS::QIC(Modelo_70_30_LO)


pred_70_30_LO = predict(Modelo_70_30_LO,test_70,type="response")
pred_70_30_LO = prediction(pred_70_30_LO, test_70$PEX)
perf_70_30_LO = performance(pred_70_30_LO, "acc")

#ACC
max_ind_70_30_LO = which.max(slot(perf_70_30_LO, "y.values")[[1]] )
acc_70_30_LO = slot(perf_70_30_LO, "y.values")[[1]][max_ind_70_30_LO]
tab2[3,1] = acc_70_30_LO

#Curva ROC
roc_70_30_LO = performance(pred_70_30_LO,"tpr","fpr")
plot(roc_70_30_LO, colorize = T, lwd = 2)
auc_70_30_LO = performance(pred_70_30_LO, measure = "auc")
tab2[3,2]  = auc_70_30_LO@y.values[[1]]
tab2


Modelo_70_30_LO_full = geeglm(PEX~Lat + Dilpp + Local_da_LIO , id = Processo , data = data, family = binomial, corstr = "exchangeable")
summary(Modelo_70_30_LO_full)
MESS::QIC(Modelo_70_30_LO_full)

```

Considerando as metricas obtidas por a validação através das curvas ROC e respetivas AUC's, é possível identificar que o modelo considerando apenas as variáveis relacionadas com a lente intraocular e respetivas posições (Modelo_LO), permite uma melhor análise de forma a identificar a influência de cada uma destas variáveis na Pseudoexfoliação ocular.
Posto isto foram desenvolvidos dois modelos (utilizando o package gee e geepack) considerando todo o dataset de modo a considerar os clusters de cada individuo.

``` {r}



GEE_Modelo_LO = gee(PEX~Local_da_LIO + Dilpp + Lat + I(Idade) + Sexo  , id = Processo, data = data_for_gee, family = binomial(link = "logit"), corstr = "exchangeable",scale.fix = T)
summary(GEE_Modelo_LO)
#Intervalos de confiança
ccgee = coef(summary(GEE_Modelo_LO))
citab_gee <- with(as.data.frame(ccgee),
     cbind(lwr=Estimate-1.96*`Robust S.E.`,
           upr=Estimate+1.96*`Robust S.E.`))
rownames(citab_gee) <- rownames(ccgee)
ccgee1 = as.data.frame(cbind(ccgee,citab_gee))
ccgee1$Estimate = exp(ccgee1$Estimate)
ccgee1$lwr = exp(ccgee1$lwr)
ccgee1$upr = exp(ccgee1$upr)
ccgee1



#Package GEEPACK
GEEPACK_Modelo_TOTAL = geeglm(PEX ~ Local_da_LIO + Dilpp + Lat + I(Idade) + Sexo, id = Processo, data = data, family = binomial, corstr = "exchangeable",scale.fix = T)
summary(GEEPACK_Modelo_LO)
MESS::QIC(GEEPACK_Modelo_LO)


#Intervalos de confiança
ccgeepack = coef(summary(GEEPACK_Modelo_TOTAL))
citab_geepack <- with(as.data.frame(ccgeepack),
     cbind(lwr=Estimate-1.96*Std.err,
           upr=Estimate+1.96*Std.err))
rownames(citab_geepack) <- rownames(ccgeepack)
ccgeepack1 = as.data.frame(cbind(ccgeepack,citab_geepack))
ccgeepack1

sapply(ccgeepack[,1], exp)
exp(ccgeepack[1,1])

ccgeepack1$Estimate = exp(ccgeepack1$Estimate)
ccgeepack1$lwr = exp(ccgeepack1$lwr)
ccgeepack1$upr = exp(ccgeepack1$upr)

```
Nos modelos acima descritos, quando utilizado o package gee, uma vez que este permite desenvolver o modelo mesmo com dados omissos existentes, foi introduzida a covariavel LIO_Dp para análise. No modelo utilizando o package geepack não foi possivel introduzir esta covariavel uma vez que esta apresenta valores omissos. Na análise dos modelos é possivel identificar algumas diferenças nas estimativas obtidas em algumas covariáveis, no entanto, na covariavel "Dil pp (mm)" as diferenças são irrelevantes, pelo que é possível identificar esta covariável como uma covariável de interesse, ou seja, tendo em conta que o seu valor estimado, verifica-se que a alteração de valor neste parâmetro influência a resposta da presença ou não da pseudoexfoliação, ou seja, uma menor dilatação pupilar poderá indicar uma presença de pseudoexfoliação.
